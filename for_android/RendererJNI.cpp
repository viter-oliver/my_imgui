/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
//#include <GLES3/gl3.h>
#include <android/asset_manager_jni.h>

#include "afg_engine.h"
GLint	g_programObject;
jint	g_width;
jint	g_height;

AAssetManager* g_pAssetManager = NULL;
//#define _DEMO_TRANGLE

static shared_ptr<afg_engine> sd_screen_engine;
GLuint LoadShader ( GLenum type, const char *shaderSrc )
{
    GLuint shader;
    GLint compiled;

    // Create the shader object
    shader = glCreateShader ( type );

    if ( shader == 0 )
    {
        return 0;
    }

    // Load the shader source
    glShaderSource ( shader, 1, &shaderSrc, NULL );

    // Compile the shader
    glCompileShader ( shader );

    // Check the compile status
    glGetShaderiv ( shader, GL_COMPILE_STATUS, &compiled );

    if ( !compiled )
    {
        GLint infoLen = 0;

        glGetShaderiv ( shader, GL_INFO_LOG_LENGTH, &infoLen );

        if ( infoLen > 1 )
        {
            char *infoLog = (char *)malloc ( sizeof ( char ) * infoLen );

            glGetShaderInfoLog ( shader, infoLen, NULL, infoLog );
            LOGE("Error compiling shader:[%s]", infoLog );

            free ( infoLog );
        }

        glDeleteShader ( shader );
        return 0;
    }

    return shader;

}
void init_demo_shader()
{
    char vShaderStr[] =
            "#version 300 es                          \n"
            "layout(location = 0) in vec3 vPosition;  \n"
            "layout(location = 1) in vec3 vColor;     \n"
            "out vec3 fragCol;                        \n"
            "void main()                              \n"
            "{                                        \n"
            "   fragCol=vColor;                       \n"
            "   gl_Position = vec4( vPosition, 1.0 );              \n"
            "}                                        \n";

    char fShaderStr[] =
            "#version 300 es                              \n"
            "precision mediump float;                     \n"
            "in vec3 fragCol;                             \n"
            "out vec4 fragColor;                          \n"
            "void main()                                  \n"
            "{                                            \n"
            "   fragColor = vec4 ( fragCol, 1.0 );        \n"
            "}                                            \n";

    GLuint vertexShader;
    GLuint fragmentShader;
    GLuint programObject;
    GLint linked;

    // Load the vertex/fragment shaders
    vertexShader = LoadShader ( GL_VERTEX_SHADER, vShaderStr );
    fragmentShader = LoadShader ( GL_FRAGMENT_SHADER, fShaderStr );
    // Create the program object
    programObject = glCreateProgram ( );

    if ( programObject == 0 )
    {
        return;
    }

    glAttachShader ( programObject, vertexShader );
    glAttachShader ( programObject, fragmentShader );

    // Link the program
    glLinkProgram ( programObject );

    // Check the link status
    glGetProgramiv ( programObject, GL_LINK_STATUS, &linked );

    if ( !linked )
    {
        GLint infoLen = 0;

        glGetProgramiv ( programObject, GL_INFO_LOG_LENGTH, &infoLen );

        if ( infoLen > 1 )
        {
            char *infoLog = (char *)malloc ( sizeof ( char ) * infoLen );

            glGetProgramInfoLog ( programObject, infoLen, NULL, infoLog );
            LOGE("Error linking program:[%s]", infoLog );

            free ( infoLog );
        }

        glDeleteProgram ( programObject );
        return;
    }

    // Store the program object
    g_programObject = programObject;

    glClearColor ( 0.0f, 0.0f, 0.0f, 0.0f );
}
#include "spectrum.h"
spectrums_manger<20> g_test_spectrums(-1.f,-0.5f,0.1f,0.08f);
void draw_trangles()
{
    GLfloat vVertices[] = {  -0.5f,  0.5f, 0.0f,0.05f,0.0f,0.0f,
                             -0.5f, -0.5f, 0.0f,1.f,0.0f,0.0f,
                             0.5f, -0.5f, 0.0f,1.f,0.0f,0.0f,
                             -0.5f,  0.5f, 0.0f,0.05f,0.0f,0.0f,
                             0.5f, -0.5f, 0.0f,1.f,0.0f,0.0f,
                             0.5f,  0.5f, 0.0f,0.05f,0.0f,0.0f
    };
    auto pspt=g_test_spectrums.get_head_address();
    float h=0.2f;
    for (int i = 0; i < 20; ++i) {
        auto bh=h+i*0.1f;
        g_test_spectrums.set_spectrum_high(i,bh);
    }
    // Set the viewport
    glViewport ( 0, 0, g_width, g_height );

    // Clear the color buffer
    glClear ( GL_COLOR_BUFFER_BIT );

    // Use the program object
    glUseProgram ( g_programObject );

    // Load the vertex data
    glEnableVertexAttribArray ( 0 );
    glVertexAttribPointer ( 0, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*6, pspt );
    glEnableVertexAttribArray ( 1);
    glVertexAttribPointer ( 1, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat)*6, pspt+3);
    glDrawArrays ( GL_TRIANGLES, 0, g_test_spectrums.get_vertex_cnt());
}
extern "C" void Java_com_example_myapplication_RendererJNI_glesInit(JNIEnv *pEnv, jobject obj) {
    glClearColor ( 1.0f, 1.0f, 1.0f, 0.0f );
    init_demo_shader();

    sd_screen_engine=make_shared<afg_engine>();
}

/*
 * Class:     opengl_panjq_com_opengl_demo_RendererJNI
 * Method:    glesRender
 * Signature: ()V
 */
extern "C" JNIEXPORT void JNICALL Java_com_example_myapplication_RendererJNI_glesRender
  (JNIEnv *pEnv, jobject obj){

    //glViewport ( 0, 0, g_width, g_height );

    // Clear the color buffer
    //glClear ( GL_COLOR_BUFFER_BIT );
#if defined(_DEMO_TRANGLE)
    draw_trangles();
    LOGI("trangle....?");
#else
    sd_screen_engine->render();
#endif

    //glDrawArrays ( GL_TRIANGLES, 0, 3 );

}

/*
 * Class:     opengl_panjq_com_opengl_demo_RendererJNI
 * Method:    glesResize
 * Signature: (II)V
 */
extern "C" JNIEXPORT void JNICALL Java_com_example_myapplication_RendererJNI_glesResize
  (JNIEnv *pEnv, jobject obj, jint width, jint height){
    g_width = width;
    g_height = height;
    sd_screen_engine->set_windows_pos(0.f,0.f)
                     .set_window_size(width,height);

}


extern "C" JNIEXPORT void JNICALL Java_com_example_myapplication_RendererJNI_readAfbFile
        (JNIEnv *env, jobject self, jobject assetManager){
    if (assetManager && env)
    {
        //LOGI("before AAssetManager_fromJava");
        g_pAssetManager = AAssetManager_fromJava(env, assetManager);
        //LOGI("after AAssetManager_fromJava");
        if (NULL == g_pAssetManager)
        {
            LOGE("AAssetManager_fromJava() return null !");
        }
        else
        {
#if 0
            LOGI("before load afb");
            AAsset* aAsset=AAssetManager_open(g_pAssetManager,"test.txt",AASSET_MODE_UNKNOWN);
            if(!aAsset)
            {
                LOGI("fail to load afb");
            }
            LOGI("after load afb");
            off_t len=AAsset_getLength(aAsset);
            LOGI("asset_len:%d",len);
            char* buff=(char*)AAsset_getBuffer(aAsset);
            buff[len]='\0';
            LOGI("fromtest:%s",buff);


            AAsset_close(aAsset);
#else
            LOGI("before load afb");
            AAsset* aAsset=AAssetManager_open(g_pAssetManager,"hst.AFB",AASSET_MODE_UNKNOWN);
            if(!aAsset)
            {
                LOGI("fail to load afb");
            }
            off_t len=AAsset_getLength(aAsset);
            LOGI("asset_len:%d",len);
            char* buff=(char*)AAsset_getBuffer(aAsset);

            sd_screen_engine->loaf_afb_from_buff(buff,len);
            LOGI("after get afb buff");
            AAsset_close(aAsset);
#endif

        }
    }
    else
    {
        LOGE("assetManager is null !");
    }
}

