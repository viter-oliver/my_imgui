1、如果一个数据块机构一样，不要冲重复定义，在外面定义一个就可以了。
比如：struct GNU_DEF struct_coor_msg
		{
			u8 valid;
			u8 warring;
			u16 value;
		};
struct GNU_DEF struct_rotate_msg
		{
			u8 valid;
			u8 warring;
			u16 value;
		};
struct GNU_DEF struct_speed_msg
		{
			u8 valid;
			u8 warring;
			u16 value;
		};
你不如定义一个struct GNU_DEF struct_valid_w_v
		{
			u8 valid;
			u8 warring;
			u16 value;
		};
然后在解析的地方
struct_valid_w_v* pcoor_msg=(struct_valid_w_v*)pbuff;
struct_valid_w_v* protate_msg=(struct_valid_w_v*)pbuff;
struct_valid_w_v* pstate_msg=(struct_valid_w_v*)pbuff;
2、不需要定义一个实例，然后memmove，例如：
                struct_inf_msg tmp;
		memmove(&tmp, pbuff, sizeof(tmp));
                struct_inf_msg *p = &tmp;
               你不如直接struct_inf_msg* p =(struct_inf_msg*）pbuff;


3、如果一个控件只有一、二个属性需要控制，建议直接通过alias来设，而不是通过alias拿到控件，再通过成员函数来设
              例如：ft_textblock *t = (ft_textblock*)get_aliase_ui_control("show_odo");
		if (p->valid == em_normal)
		{
			static int odo_v = 0;
			if (odo_v == p->value)
				return;
			if (p->value > 999999)
			{
				t->set_content("999999");

			}
			else
			{
				sprintf(show_num, "%d", p->value);
				t->set_content(show_num);
			}
			
		}
                 不如：在afg里顶一个一个alias "txt_odo";
                        然后：
                        char show_num[100]="999999";
                        if(p->value<999999)
                        {
                            sprintf(show_num, "%d", p->value);
                         }
                         set_property_aliase_value("txt_odo",show_num);


4、如果通过一个标识找到了一个对象，这个对象内部就不要存这个标识了：毕竟这个对象，你是使用这个标识找到的，说明你有这个标识，还有必要再存在这个对象内部吗？
5、很多重复判断最好去掉，（最好的代码是if else 比较少的代码）



                   